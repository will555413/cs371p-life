        -:    0:Source:/usr/include/gtest/gtest-message.h
        -:    0:Graph:TestLife.gcno
        -:    0:Data:TestLife.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Copyright 2005, Google Inc.
        -:    2:// All rights reserved.
        -:    3://
        -:    4:// Redistribution and use in source and binary forms, with or without
        -:    5:// modification, are permitted provided that the following conditions are
        -:    6:// met:
        -:    7://
        -:    8://     * Redistributions of source code must retain the above copyright
        -:    9:// notice, this list of conditions and the following disclaimer.
        -:   10://     * Redistributions in binary form must reproduce the above
        -:   11:// copyright notice, this list of conditions and the following disclaimer
        -:   12:// in the documentation and/or other materials provided with the
        -:   13:// distribution.
        -:   14://     * Neither the name of Google Inc. nor the names of its
        -:   15:// contributors may be used to endorse or promote products derived from
        -:   16:// this software without specific prior written permission.
        -:   17://
        -:   18:// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   19:// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   20:// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   21:// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   22:// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   23:// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   24:// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   25:// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   26:// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   27:// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   28:// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   29://
        -:   30:// Author: wan@google.com (Zhanyong Wan)
        -:   31://
        -:   32:// The Google C++ Testing Framework (Google Test)
        -:   33://
        -:   34:// This header file defines the Message class.
        -:   35://
        -:   36:// IMPORTANT NOTE: Due to limitation of the C++ language, we have to
        -:   37:// leave some internal implementation details in this header file.
        -:   38:// They are clearly marked by comments like this:
        -:   39://
        -:   40://   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.
        -:   41://
        -:   42:// Such code is NOT meant to be used by a user directly, and is subject
        -:   43:// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user
        -:   44:// program!
        -:   45:
        -:   46:#ifndef GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
        -:   47:#define GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
        -:   48:
        -:   49:#include <limits>
        -:   50:
        -:   51:#include "gtest/internal/gtest-string.h"
        -:   52:#include "gtest/internal/gtest-internal.h"
        -:   53:
        -:   54:namespace testing {
        -:   55:
        -:   56:// The Message class works like an ostream repeater.
        -:   57://
        -:   58:// Typical usage:
        -:   59://
        -:   60://   1. You stream a bunch of values to a Message object.
        -:   61://      It will remember the text in a stringstream.
        -:   62://   2. Then you stream the Message object to an ostream.
        -:   63://      This causes the text in the Message to be streamed
        -:   64://      to the ostream.
        -:   65://
        -:   66:// For example;
        -:   67://
        -:   68://   testing::Message foo;
        -:   69://   foo << 1 << " != " << 2;
        -:   70://   std::cout << foo;
        -:   71://
        -:   72:// will print "1 != 2".
        -:   73://
        -:   74:// Message is not intended to be inherited from.  In particular, its
        -:   75:// destructor is not virtual.
        -:   76://
        -:   77:// Note that stringstream behaves differently in gcc and in MSVC.  You
        -:   78:// can stream a NULL char pointer to it in the former, but not in the
        -:   79:// latter (it causes an access violation if you do).  The Message
        -:   80:// class hides this difference by treating a NULL char pointer as
        -:   81:// "(null)".
function _ZN7testing7MessageD2Ev called 96 returned 100% blocks executed 100%
       96:   82:class GTEST_API_ Message {
call    0 returned 100%
        -:   83: private:
        -:   84:  // The type of basic IO manipulators (endl, ends, and flush) for
        -:   85:  // narrow streams.
        -:   86:  typedef std::ostream& (*BasicNarrowIoManip)(std::ostream&);
        -:   87:
        -:   88: public:
        -:   89:  // Constructs an empty Message.
        -:   90:  // We allocate the stringstream separately because otherwise each use of
        -:   91:  // ASSERT/EXPECT in a procedure adds over 200 bytes to the procedure's
        -:   92:  // stack frame leading to huge stack frames in some cases; gcc does not reuse
        -:   93:  // the stack space.
function _ZN7testing7MessageC2Ev called 96 returned 100% blocks executed 75%
       96:   94:  Message() : ss_(new ::std::stringstream) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 never executed
call    7 never executed
call    8 never executed
        -:   95:    // By default, we want there to be enough precision when printing
        -:   96:    // a double to a Message.
       96:   97:    *ss_ << std::setprecision(std::numeric_limits<double>::digits10 + 2);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       96:   98:  }
        -:   99:
        -:  100:  // Copy constructor.
        -:  101:  Message(const Message& msg) : ss_(new ::std::stringstream) {  // NOLINT
        -:  102:    *ss_ << msg.GetString();
        -:  103:  }
        -:  104:
        -:  105:  // Constructs a Message from a C-string.
        -:  106:  explicit Message(const char* str) : ss_(new ::std::stringstream) {
        -:  107:    *ss_ << str;
        -:  108:  }
        -:  109:
        -:  110:#if GTEST_OS_SYMBIAN
        -:  111:  // Streams a value (either a pointer or not) to this object.
        -:  112:  template <typename T>
        -:  113:  inline Message& operator <<(const T& value) {
        -:  114:    StreamHelper(typename internal::is_pointer<T>::type(), value);
        -:  115:    return *this;
        -:  116:  }
        -:  117:#else
        -:  118:  // Streams a non-pointer value to this object.
        -:  119:  template <typename T>
function _ZN7testing7MessagelsIA5_cEERS0_RKT_ called 0 returned 0% blocks executed 0%
function _ZN7testing7MessagelsIA7_cEERS0_RKT_ called 15 returned 100% blocks executed 86%
function _ZN7testing7MessagelsIA12_cEERS0_RKT_ called 0 returned 0% blocks executed 0%
function _ZN7testing7MessagelsINS_8internal6StringEEERS0_RKT_ called 0 returned 0% blocks executed 0%
       15:  120:  inline Message& operator <<(const T& val) {
       15:  121:    ::GTestStreamToHelper(ss_.get(), val);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
call    7 returned 100%
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
       15:  122:    return *this;
        -:  123:  }
        -:  124:
        -:  125:  // Streams a pointer value to this object.
        -:  126:  //
        -:  127:  // This function is an overload of the previous one.  When you
        -:  128:  // stream a pointer to a Message, this definition will be used as it
        -:  129:  // is more specialized.  (The C++ Standard, section
        -:  130:  // [temp.func.order].)  If you stream a non-pointer, then the
        -:  131:  // previous definition will be used.
        -:  132:  //
        -:  133:  // The reason for this overload is that streaming a NULL pointer to
        -:  134:  // ostream is undefined behavior.  Depending on the compiler, you
        -:  135:  // may get "0", "(nil)", "(null)", or an access violation.  To
        -:  136:  // ensure consistent result across compilers, we always treat NULL
        -:  137:  // as "(null)".
        -:  138:  template <typename T>
function _ZN7testing7MessagelsIKcEERS0_RKPT_ called 15 returned 100% blocks executed 70%
       15:  139:  inline Message& operator <<(T* const& pointer) {  // NOLINT
       15:  140:    if (pointer == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  141:      *ss_ << "(null)";
call    0 never executed
call    1 never executed
        -:  142:    } else {
       15:  143:      ::GTestStreamToHelper(ss_.get(), pointer);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
        -:  144:    }
       15:  145:    return *this;
        -:  146:  }
        -:  147:#endif  // GTEST_OS_SYMBIAN
        -:  148:
        -:  149:  // Since the basic IO manipulators are overloaded for both narrow
        -:  150:  // and wide streams, we have to provide this specialized definition
        -:  151:  // of operator <<, even though its body is the same as the
        -:  152:  // templatized version above.  Without this definition, streaming
        -:  153:  // endl or other basic IO manipulators to Message will confuse the
        -:  154:  // compiler.
        -:  155:  Message& operator <<(BasicNarrowIoManip val) {
        -:  156:    *ss_ << val;
        -:  157:    return *this;
        -:  158:  }
        -:  159:
        -:  160:  // Instead of 1/0, we want to see true/false for bool values.
        -:  161:  Message& operator <<(bool b) {
        -:  162:    return *this << (b ? "true" : "false");
        -:  163:  }
        -:  164:
        -:  165:  // These two overloads allow streaming a wide C string to a Message
        -:  166:  // using the UTF-8 encoding.
        -:  167:  Message& operator <<(const wchar_t* wide_c_str) {
        -:  168:    return *this << internal::String::ShowWideCString(wide_c_str);
        -:  169:  }
        -:  170:  Message& operator <<(wchar_t* wide_c_str) {
        -:  171:    return *this << internal::String::ShowWideCString(wide_c_str);
        -:  172:  }
        -:  173:
        -:  174:#if GTEST_HAS_STD_WSTRING
        -:  175:  // Converts the given wide string to a narrow string using the UTF-8
        -:  176:  // encoding, and streams the result to this Message object.
        -:  177:  Message& operator <<(const ::std::wstring& wstr);
        -:  178:#endif  // GTEST_HAS_STD_WSTRING
        -:  179:
        -:  180:#if GTEST_HAS_GLOBAL_WSTRING
        -:  181:  // Converts the given wide string to a narrow string using the UTF-8
        -:  182:  // encoding, and streams the result to this Message object.
        -:  183:  Message& operator <<(const ::wstring& wstr);
        -:  184:#endif  // GTEST_HAS_GLOBAL_WSTRING
        -:  185:
        -:  186:  // Gets the text streamed to this object so far as a String.
        -:  187:  // Each '\0' character in the buffer is replaced with "\\0".
        -:  188:  //
        -:  189:  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.
function _ZNK7testing7Message9GetStringEv called 96 returned 100% blocks executed 100%
       96:  190:  internal::String GetString() const {
       96:  191:    return internal::StringStreamToString(ss_.get());
call    0 returned 100%
call    1 returned 100%
        -:  192:  }
        -:  193:
        -:  194: private:
        -:  195:
        -:  196:#if GTEST_OS_SYMBIAN
        -:  197:  // These are needed as the Nokia Symbian Compiler cannot decide between
        -:  198:  // const T& and const T* in a function template. The Nokia compiler _can_
        -:  199:  // decide between class template specializations for T and T*, so a
        -:  200:  // tr1::type_traits-like is_pointer works, and we can overload on that.
        -:  201:  template <typename T>
        -:  202:  inline void StreamHelper(internal::true_type /*dummy*/, T* pointer) {
        -:  203:    if (pointer == NULL) {
        -:  204:      *ss_ << "(null)";
        -:  205:    } else {
        -:  206:      ::GTestStreamToHelper(ss_.get(), pointer);
        -:  207:    }
        -:  208:  }
        -:  209:  template <typename T>
        -:  210:  inline void StreamHelper(internal::false_type /*dummy*/, const T& value) {
        -:  211:    ::GTestStreamToHelper(ss_.get(), value);
        -:  212:  }
        -:  213:#endif  // GTEST_OS_SYMBIAN
        -:  214:
        -:  215:  // We'll hold the text streamed to this object here.
        -:  216:  const internal::scoped_ptr< ::std::stringstream> ss_;
        -:  217:
        -:  218:  // We declare (but don't implement) this to prevent the compiler
        -:  219:  // from implementing the assignment operator.
        -:  220:  void operator=(const Message&);
        -:  221:};
        -:  222:
        -:  223:// Streams a Message to an ostream.
        -:  224:inline std::ostream& operator <<(std::ostream& os, const Message& sb) {
        -:  225:  return os << sb.GetString();
        -:  226:}
        -:  227:
        -:  228:}  // namespace testing
        -:  229:
        -:  230:#endif  // GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
